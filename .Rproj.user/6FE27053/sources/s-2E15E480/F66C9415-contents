###################################################
### Luigi Marchionni
### Processed GEO data from series gse
### Clinical information from the matrix available from GEO


###################################################
###################################################
###################################################
###NOTE: USE R-3.2
###################################################
###################################################
###################################################


###################################################
### Clear Workspace
rm(list=ls())

### Date
date()

### Set wd
#setwd("/Users/marchion/Research/HeadNeck/pubDomain/GEOdata/GPL570/GSE42743")

### Load libraries
library("GEOquery")

# 
##################################################
###function to retrive the information from the messed up pheno
parsePheno <- function(myPat, pheno) {
  out <- rep(NA, length=nrow(pheno))
  sel <- unlist(apply(pheno, 2, grep, pattern=myPat, value=FALSE))
  val <- unlist(apply(pheno, 2, grep, pattern=myPat, value=TRUE))
  out[sel] <- gsub(".+: ", "", val)
  out <- toupper(out)
}


###################################################
### Get the gse
gse <- getGEO("GSE42743",  getGPL = T,  GSEMatrix=T)

### Check names
names(gse)

### Get the Expression Set
esetgse <- gse[[1]]

### Check length of platform lists: if more than 1 merge
length(esetgse)

##################################################
### Process esetgse: it has length == 1

### Check phenotypes
pheno <- pData(esetgse)
dim(pheno)
str(pheno)

### Remove useless columns
pheno <- pheno[, apply(pheno, 2, function(x) length(unique(x)) > 1 )
               | colnames(pheno) == "source_name_ch1" ]

##################################################
### Process the pheno data.frame to assemble phenotypes correctly

### What kind of information is available: columns with potential
### Phenotypic information
phenoTags <- apply(pheno[, grep("characteristics", colnames(pheno)), drop=FALSE], 2, gsub,
                   pattern=":.+", replacement="")
phenoTags <- unique(as.character(phenoTags))
phenoTags <- phenoTags[!is.na(phenoTags) & phenoTags != ""]
phenoTags


### Check if the information is present also in other columns
### Not labeled by the description tag in GEO
missedTags <- apply(pheno[, -grep("characteristics", colnames(pheno)), drop=FALSE], 2, gsub,
                    pattern=":.+", replacement="")
missedTags <- unique(as.character(missedTags))
missedTags <- missedTags[!is.na(missedTags) & missedTags != ""]
str(missedTags)

### If the following is TRUE you can go ahead with phenoTags only
if (! any(missedTags %in% phenoTags)) {
  print("go ahead 'phenoTags' contains all the needed information")
} else {
  stop("Check 'missedTags' for phenotypic information")
}

### Show tags found in the pheno data.frame
sort(phenoTags)


##################################################
##################################################
### IMPORTANT: checking for metacharacters in phenotypes tags
### It is crucial to remove special characters BEFORE the semicolon!!!
##################################################

### The list of special characters
specialChar <- c("\\.", "\\\\", "\\|", "\\(", "\\)", "\\[", "\\{",
                 "\\^", "\\$", "\\*", "\\+", "\\?")

### Check for metacharactes in the phenotypes tags
anyMetaChar <- sapply(specialChar, function(x, y) {
  length(grep(x, y)) > 0
}, y = phenoTags)
anyMetaChar <- names(anyMetaChar[anyMetaChar])

### Show matacharacters used in 'phenoTags' if any
anyMetaChar

### Replace metacharacter in 'pheno' and 'phenoTags' if these are present
if (length(anyMetaChar) > 0) {
  ## Process phenotypes tags
  phenoTags <- sapply(phenoTags, function(x, y) {
    y <- paste("[", paste(y, collapse=""), "]", sep="")
    gsub(y, replacement="", x)
  }, y=anyMetaChar)
  ## Process phenotypes data.frame
  rnms <- rownames(pheno)
  pheno <- sapply(pheno, function(x, y) {
    y <- paste("[", paste(y, collapse=""), "]", sep="")
    gsub(y, replacement="", x)
  }, y=anyMetaChar)
  ## Add ronames back to pheno
  rownames(pheno) <- rnms
}


##################################################
### Resume processing phenotype information
##################################################

### Parse pheno data.frame
parsedPheno <- sapply(phenoTags, parsePheno, pheno)
colnames(parsedPheno) <- gsub(" ", ".", colnames(parsedPheno))

### Remove factors
parsedPheno <- data.frame(apply(parsedPheno, 2, as.character), stringsAsFactors=FALSE)
parsedPheno$order1 <- 1:nrow(parsedPheno)
rownames(parsedPheno) <- rownames(pheno)

### If there are Values like N/A or empty strings "", or UNKNOWN: use NA instead
parsedPheno[parsedPheno=="NA"] <- NA
parsedPheno[parsedPheno=="UNKNOWN"] <- NA
parsedPheno[parsedPheno=="N/A"] <- NA
parsedPheno[parsedPheno==""] <- NA

### Some variable should be numeric (ie time to recurrence)
sel <- c("age.dx", "futime", "order1")
parsedPheno[,sel] <- apply(parsedPheno[,sel], 2,
			   function(x) as.numeric((gsub("\\s", "", x))))

##################################################
### Modidify other columns: stage
parsedPheno$t.stage <- factor(paste("T", parsedPheno$t.stage,  sep=""))

### Modidify other columns: clinical node status
parsedPheno$cn.stage <- factor(paste("N", parsedPheno$cn.stage,  sep=""))

### Modidify other columns: pathological node status
parsedPheno$pn.stage <- factor(paste("N", parsedPheno$pn.stage,  sep=""))

### Modidify other columns: gender
parsedPheno$gender <- factor(parsedPheno$gender)


#################################################################
### Prepare extra info about samples and other GEO metadata
extraInfo <- as.data.frame(pheno[, -grep("characteristics", colnames(pheno))],
                           stringsAsFactors=FALSE)
extraInfo <- data.frame(apply(extraInfo, 2, as.character),stringsAsFactors=FALSE)
extraInfo$order2 <- 1:nrow(extraInfo)
rownames(extraInfo) <- extraInfo[, "geo_accession"]

### Merge the metadata with rest of the phenotypic information
finalPheno <- merge(extraInfo,  parsedPheno, by=0, all=FALSE,
                    stringsAsFactors=FALSE)

### Reorder and then check order
finalPheno <- finalPheno[order(as.numeric(finalPheno$order1)),]
all(finalPheno$order1 == finalPheno$order2)
all(finalPheno[, "Row.names"] %in% rownames(pheno))
all(finalPheno[, "Row.names"] == rownames(pheno))

### Set rownames
if (all(finalPheno[, "Row.names"] == rownames(pheno))) {
  rownames(finalPheno) <- rownames(pheno)
  print("All rows in phenoData are in the good order")
} else {
  stop("check the row order")
}


##################################################
### Create a new ExpressionSet instance
pData(esetgse) <- finalPheno


#################################################################
### Add information about genes
tmp <- esetgse

### Load annotated eset
load("/Volumes/Macintosh/Research/Projects/HNSCC/Data/GSE3292/esetGSE3292.rda")

### Check order of features
feat <- intersect(featureNames(tmp), featureNames(esetgse))

### Extract
ann <- featureData(esetgse)[feat, ]

###Assign
featureData(tmp) <- ann

### Check validity
validObject(tmp)

### replace and save
esetgse <- tmp

### Check validity
validObject(esetgse)


##################################################
###writinf the data to a file
write.table(finalPheno, file="./Objs/GSE42743.txt", sep="\t", row.names=F, col.names=T)

##################################################
### Save
save(esetgse, file="./Objs/esetGSE42743.rda")


###################################################
### Session information and clean quit

### Session
sessionInfo()

### Get the date
date()

### Clean
rm(list=ls())

### Quit
q("no")
